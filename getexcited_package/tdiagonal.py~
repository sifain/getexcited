#/usr/bin/python

'''
    
This function calculates the diagonal elements of the transition 
density in time.

The user must supply how the molecule is to be divided.  This is 
accomplished by defining atom numbers, according to how they are 
ordered in a general input file.  The atom numbers are to be 
written in a user-generated file, where the keyword 'break' is 
to be inserted wherever a new fragment of the molecule is defined.  

Type of calculation:

[1] Single Trajectory
< sample input.ceon file with molecule, fragment file, collection time (fs)
> time (fs), occupied state (t), occupied state (t+dt), occupancies in same order as fragment file (sums to 1)

[2] Ensemble of Trajectories

[2a] Mean
< sample input.ceon file with molecule, fragment file, collection time (fs)
> time (fs), occupied state (t), occupied state (t+dt), occupancies in same order as fragment file (sums to 1)

[2b] All time-steps
< sample input.ceon file with molecule, fragment file, collection time (fs)
> trajectory directory, time (fs), occupied state (t), occupied state (t+dt), occupancies in same order as fragment file (sums to 1)

[2c] User-defined time
< sample input.ceon file with molecule, fragment file, collection time (fs)
> trajectory directory, time (fs), occupied state (t), occupied state (t+dt), occupancies in same order as fragment file (sums to 1)

Output Files:
- td_[type].out, where [type] = single, mean_ensemble, raw_ensemble

Error Files:
- td_[type].out, where [type] = single, mean_ensemble, raw_ensemble

'''

import numpy as np
import os
import sys
import glob

CWD = os.getcwd()

def TDIAGONAL():

    print 'Calculating occupation of excitation as a function of time according to transition densities.'

    ## TYPE OF CALCULATION AND DIRECTORY CHECK ##
    DYNQ = input('Calculate occupation along one trajectory or an ensemble of trajectories?\nAnswer ONE [1] or ENSEMBLE [0]: ')
    if DYNQ not in [1,0]:
        print 'Answer must be 1 or 0.'
        sys.exit()
    if DYNQ == 0: ## ENSEMBLE
        NEXMDIR = raw_input('Ensemble directory [e.g. nexmd]: ')
        if not os.path.exists(NEXMDIR):
            print 'Path %s does not exist.' % (NEXMDIR)
            sys.exit()
        ## CHECK IF NEXMD FOLDERS EXIST ##
        NEXMDS = glob.glob('%s/NEXMD*/' % (NEXMDIR))
        NEXMDS.sort()
        if len(NEXMDS) == 0:
            print 'There are no NEXMD folders in %s.' % (NEXMDIR)
            sys.exit()
        ## DETERMINE MEAN OR ALL ##
        TYPEQ = input('Output mean occupation in time, at all time-steps and trajectories, or up to some user-defined time? Answer MEAN [0], ALL [1], or USER-DEFINED [2]: ')
        if TYPEQ not in [0,1,2]:
            print 'Answer must be 0, 1, or 2.'
            sys.exit()
    if DYNQ == 1: ## SINGLE TRAJECTORY
        TYPEQ = 0
        NEXMDIR = raw_input('Single trajectory directory: ')
        if not os.path.exists(NEXMDIR):
            print 'Path %s does not exist.' % (NEXMDIR)
            sys.exit()
            
    ## NUMBER AND TYPE OF COORDINATES ##
    COORDQ = raw_input('Directory with an input.ceon file for coordinates, do not include input.ceon in the path: ')
    if not os.path.exists('%s/input.ceon' % (COORDQ)):
        print 'Path %s/input.ceon does not exist.' % (COORDQ)
        sys.exit()
    COORDS = open('%s/input.ceon' % (COORDQ),'r')
    COORDS = COORDS.readlines()
    INDEX = 0
    for LINE in COORDS:
        if '&coord' in LINE:
            LOW = INDEX
        if '&endcoord' in LINE:
            HIGH = INDEX
        INDEX += 1
    NATOMS = (HIGH - 1) - (LOW + 1) + 1
    ORBITALS = np.array([])
    for LINE in COORDS[LOW + 1:HIGH:1]:
        ATYPE = np.int(LINE.split()[0])
        if ATYPE == 1:
            ORBITALS = np.append(ORBITALS,1)
        else:
            ORBITALS = np.append(ORBITALS,4)
    ## NUMBER OF ORBITALS ##
    NORBITS = np.int(np.sum(ORBITALS))
    ## INDICES TO SPLIT THE ORBITALS ##
    ORBITALS = np.cumsum(ORBITALS)

    ## FRAGMENTS OF THE MOLECULE ##
    FRAGQ = raw_input('Directory with fragment file, include name of file in the path: ')
    if not os.path.exists(FRAGQ):
        print 'Path %s does not exist.' % (FRAGQ)
        sys.exit()
    FRAG = open('%s' % (FRAGQ),'r')
    FRAG = FRAG.readlines()
    BARRAY = np.array([])
    FRAGMENTS = np.array([])
    INDEX = 0
    for LINE in FRAG:
        if 'break' in LINE:
            BARRAY = np.append(BARRAY, INDEX - len(BARRAY))
        else:
            FRAGMENTS = np.append(FRAGMENTS, np.int(LINE.split()[0]) - 1) ## - 1 FOR PYTHON INDEXING
        INDEX += 1
    if len(FRAGMENTS) != NATOMS:
        print 'Number of atoms in the fragment file is not consistent with the coordinate file.'
        sys.exit()
    FRAGMENTS = np.split(FRAGMENTS, BARRAY)
    NFRAG = len(FRAGMENTS)

    ## INFORMATION FROM HEADER ##
    if DYNQ == 0: ## ENSEMBLE
        if not os.path.exists('%s/header' % (NEXMDIR)):
            print 'Path %s/header does not exist.' % (NEXMDIR)
            sys.exit()
        HEADER = open('%s/header' % (NEXMDIR),'r')
        HEADER = HEADER.readlines()
    if DYNQ == 1: ## SINGLE TRAJECTORY
        if not os.path.exists('%s/input.ceon' % (NEXMDIR)):
            print 'Path %s/input.ceon does not exist.' % (NEXMDIR)
            sys.exit()
        HEADER = open('%s/input.ceon' % (NEXMDIR))
        HEADER = HEADER.readlines()
    STATEINIT = None
    for LINE in HEADER:
        if 'bo_dynamics_flag' in LINE:
            BOFLAG = np.int(LINE.split()[0][len('bo_dynamics_flag='):-1])
        if 'exc_state_init=' in LINE:
            STATEINIT = np.int(LINE.split()[0][len('exc_state_init='):-1])
        if 'time_init' in LINE:
            TINITH = np.float(LINE.split()[0][len('time_init='):-1])
        if 'time_step' in LINE:
            DT = np.float(LINE.split()[0][len('time-step='):-1])
        if 'n_class_steps' in LINE:
            TSMAX = np.int(LINE.split()[0][len('n_class_steps='):-1]) + 1
        if 'out_data_steps' in LINE:
            ODATA = np.int(LINE.split()[0][len('out_data_steps='):-1])
    if BOFLAG == 1 and STATEINIT == None:
        print 'Dynamics are set to Born-Oppenheimer, but the initial state is not set.\nPlease check bo_dynamics_flag and exc_state_init in header.'
        sys.exit()
    
    ## COLLECTION TIME ##
    if TYPEQ == 0: ## MEAN OCCUPATION
        if DYNQ == 0: ## ENSEMBLE
            TCOLL = input('Calculate occupation up to what time in femtoseconds?\nNote that averaged results will only include trajectories that are complete up to this time: ')
        if DYNQ == 1: ## SINGLE TRAJECTORY
            TCOLL = input('Calculate occupation up to what time in femtoseconds? ')
        if isinstance(TCOLL, int) == False and isinstance(TCOLL, float) == False:
            print 'Time must be integer or float.'
            sys.exit()
        if TCOLL < 0:
            print 'Time must be integer or float greater than zero.'
            sys.exit()
        TCOLL = np.float(TCOLL)
        NSTEPS = 1
        while NSTEPS*DT <= TCOLL:
            NSTEPS += 1
        TCOLL = (NSTEPS - 1)*DT
        if TCOLL > (TSMAX - 1)*DT:
            TCOLL = (TSMAX - 1)*DT
    if TYPEQ == 1: ## ALL OCCUPATIONS
        TCOLL = (TSMAX - 1)*DT
    if TYPEQ == 2: ## ALL UP TO USER-DEFINED TIME
        TCOLL = input('Calculate occupation up to what time in femtoseconds? ')
        if isinstance(TCOLL, int) == False and isinstance(TCOLL, float) == False:
            print 'Time must be integer or float.'
            sys.exit()
        if TCOLL < 0:
            print 'Time must be integer or float greater than zero.'
            sys.exit()
        TCOLL = np.float(TCOLL)
        NSTEPS = 1
        while NSTEPS*DT <= TCOLL:
            NSTEPS += 1
        TCOLL = (NSTEPS - 1)*DT
        if TCOLL > (TSMAX - 1)*DT:
            TCOLL = (TSMAX - 1)*DT

    ## NUMBER OF CLASSICAL STEPS ##
    TSCOL = 0
    while TSCOL*DT*ODATA <= TCOLL:
        TSCOL += 1
        
    ## LINE NUMBERS AND COLLECTION TIME ARRAY ##
    LINENUMS = np.arange(TSCOL)
    TIMES = np.around(np.linspace(TINITH, TCOLL, TSCOL), decimals  = 3)

    ## SINGLE ADIABATIC TRAJECTORY ##
    if DYNQ == 1 and BOFLAG == 1:
        ## ALL TIME-STEPS - SINGLE ADIABATIC TRAJECTORY ##
        if TYPEQ == 1:
            ## GENERATE OUTPUT FILE ##
            OUTPUT = open('%s/td_single.out' % (CWD),'w')
            ## BEGIN LOOPING OVER TRAJECTORY ##
            TTRAJ = 0
            CTRAJ = 0
            ETRAJ = 0
            ## DETERMINE COMPLETED NUMBER OF TIME-STEPS ##
            if not os.path.exists('%s/energy-ev.out' % (NEXMDIR)):
                print 'Path %s/energy-ev.out does not exist.' % (NEXMDIR)
                sys.exit()
            DATA = open('%s/energy-ev.out' % (NEXMDIR),'r')
            DATA = DATA.readlines()
            TSTEPS = len(DATA) - 1
            ## DETERMINE IF TRANSITION DENSITY FILE EXISTS AND OPEN IT ##
            if not os.path.exists('%s/transition-densities.out' % (NEXMDIR)):
                print 'Path %s/transition-densities.out does not exist.' % (NEXMDIR)
                sys.exit()
            TDS = open('%s/transition-densities.out' % (NEXMDIR),'r')
            TDS = TDS.readlines()
            ## COLLECT DATA ##
            TFLAG = 0
            INDEX = 0
            for LINE in LINENUMS:
                VAL = np.float_(TDS[LINE].split())
                TIME = np.around(VAL[0], decimals = 3)
                if TIME != TIMES[INDEX]:
                    print 'There is an inconsistency in time-step in %s at %.3f fs.' % (NEXMDIR,TIMES[INDEX])
                    TFLAG = 1
                    break
                print >> OUTPUT, '%s' % (NEXMDIR), '%d' % (STATEINIT), '%d' (STATEINIT), ' '.join(str('%.10f') % (x) for x in np.abs(VAL[1::])/np.sum(np.abs(VAL[1::])))
                INDEX += 1
            if TFLAG == 0:
                CTRAJ += 1
                if TSTEPS == TSMAX:
                    ETRAJ += 1
            print '%s' % (NEXMDIR), '%0*.2f' % (len(str(TSMAX)) + 2, (TSTEPS - 1)*DT)
            TTRAJ += 1
            ## SUMMARY OF RESULTS ##
            if CTRAJ == 0:
                print 'No trajectories completed within %0*.2f fs.' % (len(str(TSMAX)), TCOLL)
                os.remove('%s/td_single.out' % (CWD))
            else:
                print 'Total Trajectories:', '%04d' % (TTRAJ)
                print 'Completed Trajectories:', '%04d' % (CTRAJ)
                print 'Excellent Trajectories:', '%04d' % (ETRAJ)
        
        ## USER-DEFINED TIME-STEPS - SINGLE ADIABATIC TRAJECTORY ##
        if TYPEQ == 2:
            ## GENERATE OUTPUT FILE ##
            OUTPUT = open('%s/td_single.out' % (CWD),'w')
            ## BEGIN LOOPING OVER TRAJECTORY ##
            TTRAJ = 0
            CTRAJ = 0
            ETRAJ = 0
            ## DETERMINE COMPLETED NUMBER OF TIME-STEPS ##
            if not os.path.exists('%s/energy-ev.out' % (NEXMDIR)):
                print 'Path %s/energy-ev.out does not exist.' % (NEXMDIR)
                sys.exit()
            DATA = open('%s/energy-ev.out' % (NEXMDIR),'r')
            DATA = DATA.readlines()
            TSTEPS = len(DATA) - 1
            ## DETERMINE IF TRANSITION DENSITY FILE EXISTS AND OPEN IT ##
            if not os.path.exists('%s/transition-densities.out' % (NEXMDIR)):
                print 'Path %s/transition-densities.out does not exist.' % (NEXMDIR)
                sys.exit()
            TDS = open('%s/transition-densities.out' % (NEXMDIR),'r')
            TDS = TDS.readlines()
            ## COMPARE COMPLETED TIME-STEPS TO COLLECTION TIME-STEPS AND COLLECT DATA ##
            if TSTEPS >= TSCOL:
                TFLAG = 0
                INDEX = 0
                for LINE in LINENUMS:
                    VAL = np.float_(TDS[LINE].split())
                    TIME = np.around(VAL[0], decimals = 3)
                    if TIME != TIMES[INDEX]:
                        print 'There is an inconsistency in time-step in %s at %.3f fs.' % (NEXMDIR,TIMES[INDEX])
                        TFLAG = 1
                        break
                    print >> OUTPUT, '%s' % (NEXMDIR), '%d' % (STATINIT), '%d' % (STATEINIT), ' '.join(str('%.10f') % (x) for x in np.abs(VAL[1::])/np.sum(np.abs(VAL[1::])))
                    INDEX += 1
                if TFLAG == 0:
                    CTRAJ += 1
                    if TSTEPS == TSMAX:
                        ETRAJ += 1
                print '%s' % (NEXMDIR), '%0*.2f' % (len(str(TSMAX)) + 2, (TSTEPS - 1)*DT)
                TTRAJ += 1
                ## SUMMARY OF RESULTS ##
                if CTRAJ == 0:
                    print 'No trajectories completed within %0*.2f fs.' % (len(str(TSMAX)), TCOLL)
                    os.remove('%s/td_single.out' % (CWD))
                else:
                    print 'Total Trajectories:', '%04d' % (TTRAJ)
                    print 'Completed Trajectories:', '%04d' % (CTRAJ)
                    print 'Excellent Trajectories:', '%04d' % (ETRAJ)

    ## SINGLE NON-ADIABATIC TRAJECTORY ##
    if DYNQ == 1 and BOFLAG == 0:
        ## ALL TIME-STEPS - SINGLE NON-ADIABATIC TRAJECTORY ##
        if TYPEQ == 1:
            ## GENERATE OUTPUT FILE ##
            OUTPUT = open('%s/td_single.out' % (CWD),'w')
            ## BEGIN LOOPING OVER TRAJECTORY ##
            TTRAJ = 0
            CTRAJ = 0
            ETRAJ = 0
            ## DETERMINE COMPLETED NUMBER OF TIME-STEPS ##
            if not os.path.exists('%s/energy-ev.out' % (NEXMDIR)):
                print 'Path %s/energy-ev.out does not exist.' % (NEXMDIR)
                sys.exit()
            DATA = open('%s/energy-ev.out' % (NEXMDIR),'r')
            DATA = DATA.readlines()
            TSTEPS = len(DATA) - 1
            ## DETERMINE IF COEFFICIENT FILE EXISTS AND OPEN IT ##
            if not os.path.exists('%s/coeff-n.out' % (NEXMDIR)):
                print 'Path %s/coeff-n.out does not exist.' % (NEXMDIR)
                sys.exit()
            HOPS = open('%s/coeff-n.out' % (NEXMDIR),'r')
            HOPS = HOPS.readlines()
            HSTEPS = len(HOPS)
            ## DETERMINE IF TRANSITION DENSITY FILE EXISTS AND OPEN IT ##
            if not os.path.exists('%s/transition-densities.out' % (NEXMDIR)):
                print sys.exit()
            TDS = open('%s/transition-densities.out' % (NEXMDIR),'r')
            TDS = TDS.readlines()
            ## COLLECT DATA ##
            TFLAG = 0
            INDEX = 0
            CSTATE = np.int(HOPS[0].split()[0])
            for LINE in LINENUMS:
                if LINE <= HSTEPS:
                    NSTATE = np.int(HOPS[LINE].split()[0])
                VAL = np.float_(TDS[LINE].split())
                TIME = np.around(VAL[0], decimals = 3)
                if TIME != TIMES[INDEX]:
                    print 'There is an inconsistency in time-step in %s at %.3f fs.' % (NEXMDIR,TIMES[INDEX])
                    TFLAG = 1
                    break
                print >> OUTPUT, '%s' % (NEXMDIR), '%d' % (CSTATE), '%d' % (NSTATE), ' '.join(str('%.10f') % (x) for x in np.abs(VAL[1::])/np.sum(np.abs(VAL[1::])))
                CSTATE = NSTATE
                INDEX += 1
            if TFLAG == 0:
                CTRAJ += 1
                if TSTEPS == TSMAX:
                    ETRAJ += 1
            print '%s' % (NEXMDIR), '%0*.2f' % (len(str(TSMAX)) + 2, (TSTEPS - 1)*DT)
            TTRAJ += 1
            ## SUMMARY OF RESULTS ##
            if CTRAJ == 0:
                print 'No trajectories completed within %0*.2f fs.' % (len(str(TSMAX)), TCOLL)
                os.remove('%s/td_single.out' % (CWD))
            else:
                print 'Total Trajectories:', '%04d' % (TTRAJ)
                print 'Completed Trajectories:', '%04d' % (CTRAJ)
                print 'Excellent Trajectories:', '%04d' % (ETRAJ)

        ## USER-DEFINED TIME-STEPS - SINGLE NON-ADIABATIC TRAJECTORY ##
        if TYPEQ == 2:
            ## GENERATE OUTPUT FILES ##
            OUTPUT = open('%s/td_single.out' % (CWD),'w')
            ## BEGIN LOOPING OVER TRAJECTORY ##
            TTRAJ = 0
            CTRAJ = 0
            ETRAJ = 0
            ## DETERMINE COMPLETED NUMBER OF TIME-STEPS ##
            if not os.path.exists('%s/energy-ev.out' % (NEXMDIR)):
                print 'Path %s/energy-ev.out does not exist.' % (NEXMDIR)
                sys.exit()
            DATA = open('%s/energy-ev.out' % (CWD),'r')
            DATA = DATA.readlines()
            TSTEPS = len(DATA) - 1
            ## DETERMINE IF COEFFICIENT FILE EXISTS AND OPEN IT ##
            if not os.path.exists('%s/coeff-n.out' % (NEXMDIR)):
                print 'Path %s/coeff-n.out does not exist.' % (NEXMDIR)
                sys.exit()
            HOPS = open('%s/coeff-n.out' % (NEXMDIR),'r')
            HOPS = HOPS.readlines()
            HSTEPS = len(HOPS)
            ## DETERMINE IF TRANSITION DENSITY FILE EXISTS AND OPEN IT ##
            if not os.path.exists('%s/transition-densities.out' % (NEXMDIR)):
                print 'Path %s/transition-densities.out does not exist.' % (NEXMDIR)
                sys.exit()
            TDS = open('%s/transition-densities.out' % (NEXMDIR),'r')
            TDS = TDS.readlines()
            ## COMPARE COMPLETED TIME-STEPS TO COLLECTION TIME-STEPS AND COLLECT DATA ##
            if TSTEPS >= TSCOL:
                TFLAG = 0
                INDEX = 0
                CSTATE = np.int(HOPS[0].split()[0])
                for LINE in LINENUMS:
                    if LINE <= HSTEPS:
                        NSTATE = np.int(HOPS[LINE].split()[0])
                    VAL = np.float_(TDS[LINE].split()[0])
                    TIME = np.around(VAL[0], decimals = 3)
                    if TIME != TIMES[INDEX]:
                        print 'There is an inconsistency in time-step in %s at %.3f fs.' % (NEXMDIR,TIMES[INDEX])
                        TFLAG = 1
                        break
                    print >> OUTPUT, '%s' % (NEXMDIR), '%d' % (CSTATE), '%d' % (NSTATE), ' '.join(str('%.10f') % (x) for x in np.abs(VAL[1::])/np.sum(np.abs(VAL[1::])))
                    CSTATE = NSTATE
                    INDEX += 1
            if TFLAG == 0:
                CTRAJ += 1
                if TSTEPS == TSMAX:
                    ETRAJ += 1
            print '%s' % (NEXMDIR), '%0*.2f' % (len(str(TSMAX)) + 2, (TSTEPS - 1)*DT)
            TTRAJ += 1
            ## SUMMARY OF RESULTS ##
            if CTRAJ == 0:
                print 'No trajectories completed within %0*.2f fs.' % (len(str(TSMAX)), TCOLL)
                os.remove('%s/td_single.out' % (CWD))
            else:
                print 'Total Trajectories:', '%04d' % (TTRAJ)
                print 'Completed Trajectories:', '%04d' % (CTRAJ)
                print 'Excellent Trajectories:', '%04d' % (ETRAJ)

    ## ADIABATIC ENSEMBLE ##
    if DYNQ == 0 and BOFLAG == 1:
        ## ALL TIME-STEPS - ADIABATIC ENSEMBLE ##
        if TYPEQ == 1:
            ## GENERATE OUTPUT/ERROR FILES ##
            OUTPUT = open('%s/td_raw_ensemble.out' % (CWD),'w')
            ERROR = open('%s/td_raw_ensemble.err' % (CWD),'w')
            ## BEGIN LOOPING OVER TRAJECTORIES ##
            TTRAJ = 0
            CTRAJ = 0
            ETRAJ = 0
            ERRFLAG = 0
            for NEXMD in NEXMDS:
                if not os.path.exists('%s/dirlist1' % (NEXMD)):
                    print 'Path %sdirlist1 does not exist.' % (NEXMD)
                    sys.exit()
                DIRLIST1 = np.int_(np.genfromtxt('%s/dirlist1' % (NEXMD)))
                if isinstance(DIRLIST1,int) == True:
                    DIRLIST1 = np.array([DIRLIST1])
                for DIR in DIRLIST1:
                    ## DETERMINE COMPLETED NUMBER OF TIME-STEPS ##
                    if not os.path.exists('%s/%04d/energy-ev.out' % (NEXMD,DIR)):
                        print >> ERROR, '%s%04d/energy-ev.out' % (NEXMD,DIR), 'does not exist'
                        ERRFLAG = 1
                        TTRAJ += 1
                        continue
                    DATA = open('%s/%04d/energy-ev.out' % (NEXMD,DIR),'r')
                    DATA = DATA.readlines()
                    TSTEPS = len(DATA) - 1
                    ## DETERMINE IF TRANSITION DENSITY FILES EXIST AND OPEN THEM ##
                    if not os.path.exists('%s/%04d/transition-densities.out' % (NEXMD,DIR)):
                        print >> ERROR, '%s%04d/transition-densities.out' % (NEXMD,DIR), 'does not exist'
                        ERRFLAG = 1
                        TTRAJ += 1
                        continue
                    TDS = open('%s/%04d/transition-densities.out' % (NEXMD,DIR),'r')
                    TDS = TDS.readlines()
                    ## COLLECT DATA ##
                    TFLAG = 0
                    INDEX = 0
                    for LINE in LINENUMS:
                        VAL = np.float_(TDS[LINE].split())
                        TIME = np.around(VAL[0], decimals = 3)
                        if TIME != TIMES[INDEX]:
                            print >> ERROR, 'There is an inconsistency in time-step in %s%04d at %.3f fs' % (NEXMD,DIR,TIMES[INDEX])
                            TFLAG = 1
                            ERRFLAG = 1
                            break
                        print >> OUTPUT, '%s%04d' % (NEXMD,DIR), '%d' % (STATEINIT), '%d' % (STATEINIT), ' '.join(str('%.10f') % (x) for x in np.abs(VAL[1::])/np.sum(np.abs(VAL[1::])))
                        INDEX += 1
                    if TFLAG == 0:
                        CTRAJ += 1
                        if TSTEPS == TSMAX:
                            ETRAJ += 1
                    print '%s%04d' % (NEXMD,DIR), '%0*.2f' % (len(str((TSMAX))) + 2, (TSTEPS - 1)*DT)
                    TTRAJ += 1
            ## SUMMARY OF RESULTS ##
            if CTRAJ == 0:
                print 'No trajectories completed within %0*.2f fs.' % (len(str(TSMAX)), TCOLL)
                os.remove('%s/td_raw_ensemble.out' % (CWD))
            else:
                print 'Total Trajectories:', '%04d' % (TTRAJ)
                print 'Completed Trajectories:', '%04d' % (CTRAJ)
                print 'Excellent Trajectories:', '%04d' % (ETRAJ)
            if ERRFLAG == 1:
                print 'One or more trajectories have experienced an error, check td_raw_ensemble.err.' % (len(str(TSMAX)), TCOLL)
            else:
                os.remove('%s/td_raw_ensemble.err' % (CWD))

        ## USER-DEFINED TIME-STEPS - ADIABATIC ENSEMBLE ##
        if TYPEQ == 2:
            ## GENERATE OUTPUT/ERROR FILES ##
            OUTPUT = open('%s/td_raw_ensemble.out' % (CWD),'w')
            ERROR = open('%s/td_raw_ensemble.err' % (CWD),'w')
            ## BEGIN LOOPING OVER TRAJECTORIES ##
            TTRAJ = 0
            CTRAJ = 0
            ETRAJ = 0
            ERRFLAG = 0
            for NEXMD in NEXMDS:
                if not os.path.exists('%s/dirlist1' % (NEXMD)):
                    print 'Path %sdirlist1 does not exist.' % (NEXMD)
                    sys.exit()
                DIRLIST1 = np.int_(np.genfromtxt('%s/dirlist1' % (NEXMD)))
                if isinstance(DIRLIST1, int) == True:
                    DIRLIST1 = np.array([DIRLIST1])
                for DIR in DIRLIST1:
                    ## DETERMINE COMPLETED NUMBER OF TIME-STEPS ##
                    if not os.path.exists('%s/%04d/energy-ev.out' % (NEXMD,DIR)):
                        print >> ERROR, '%s%04d/energy-ev.out' % (NEXMD,DIR), 'does not exist'
                        ERRFLAG = 1
                        TTRAJ += 1
                        continue
                    DATA = open('%s/%04d/energy-ev.out' % (NEXMD,DIR),'r')
                    DATA = DATA.readlines()
                    TSTEPS = len(DATA) - 1
                    ## DETERMINE IF TRANSITION DENSITY FILES EXIST AND OPEN THEM ##
                    if not os.path.exists('%s/%04d/transition-densities.out' % (NEXMD,DIR)):
                        print >> ERROR, '%s%04d/transition-densities.out' % (NEXMD,DIR)
                        ERRFLAG = 1
                        TTRAJ += 1
                        continue
                    TDS = open('%s/%04d/transition-densities.out' % (NEXMD,DIR),'r')
                    TDS = TDS.readlines()
                    ## COMPARE COMPLETED TIME-STEPS TO COLLECTION TIME-STEPS AND COLLECT DATA ##
                    if TSTEPS >= TSCOL:
                        TFLAG = 0
                        INDEX = 0
                        for LINE in LINENUMS:
                            VAL = np.float_(TDS[LINE].split())
                            TIME = np.around(VAL[0], decimals = 3)
                            if TIME != TIMES[INDEX]:
                                print >> ERROR, 'There is an inconsistency in time-step in %s%04d at %.3f fs' % (NEXMD,DIR,TIMES[INDEX])
                                TFLAG = 1
                                ERRFLAG = 1
                                break
                            print >> OUTPUT, '%s%04d' % (NEXMD,DIR), '%d' % (STATEINIT), '%d' % (STATEINIT), ' '.join(str('%.10f') % (x) for x in np.abs(VAL[1::])/np.sum(np.abs(VAL[1::])))
                            INDEX += 1
                        if TFLAG == 0:
                            CTRAJ += 1
                            if TSTEPS == TSMAX:
                                ETRAJ += 1
                    else:
                        print >> ERROR, '%s%04d' % (NEXMD,DIR), '%0*.2f' % (len(str((TSMAX))) + 2, (TSTEPS - 1)*DT)
                        ERRFLAG = 1
                    print '%s%04d' % (NEXMD,DIR), '%0*.2f' % (len(str((TSMAX))) + 2, (TSTEPS - 1)*DT)
                    TTRAJ += 1
            ## SUMMARY OF RESULTS ##
            if CTRAJ == 0:
                print 'No trajectories completed within %0*.2f fs.' % (len(str(TSMAX)), TCOLL)
                os.remove('%s/td_raw_ensemble.out' % (CWD))
            else:
                print 'Total Trajectories:', '%04d' % (TTRAJ)
                print 'Completed Trajectories:', '%04d' % (CTRAJ)
                print 'Excellent Trajectories:', '%04d' % (ETRAJ)
            if ERRFLAG == 1:
                print 'One or more trajectories have experienced an error, check td_raw_ensemble.err.' % (len(str(TSMAX)), TCOLL)
            else:
                os.remove('%s/td_raw_ensemble.err' % (CWD))

        ## CALCULATE MEAN - ADIABATIC ENSEMBLE ##
        if TYPEQ == 0:
            ## GENERATE OCCUPANCY ARRAY FOR FINAL RESULTS ##
            FOCC = np.zeros((TSCOL,NATOMS))
            ## GENERATE OUTPUT/ERROR FILES ##
            OUTPUT = open('%s/td_mean_ensemble.out' % (CWD),'w')
            ERROR = open('%s/td_mean_ensemble.err' % (CWD),'w')
            ## BEGIN LOOPING OVER TRAJECTORIES ## 
            TTRAJ = 0
            CTRAJ = 0
            ETRAJ = 0
            ERRFLAG = 0
            for NEXMD in NEXMDS:
                if not os.path.exists('%s/dirlist1' % (NEXMD)):
                    print 'Path %sdirlist1 does not exist.' % (NEXMD)
                    sys.exit()
                DIRLIST1 = np.int_(np.genfromtxt('%s/dirlist1' % (NEXMD)))
                if isinstance(DIRLIST1, int) == True:
                    DIRLIST1 = np.array([DIRLIST1])
                for DIR in DIRLIST1:
                    ## DETERMINE COMPLETED NUMBER OF TIME-STEPS ##
                    if not os.path.exists('%s/%04d/energy-ev.out' % (NEXMD,DIR)):
                        print >> ERROR, '%s%04d/energy-ev.out' % (NEXMD,DIR), 'does not exist'
                        ERRFLAG = 1
                        TTRAJ += 1
                        continue
                    DATA = open('%s/%04d/energy-ev.out' % (NEXMD,DIR),'r')
                    DATA = DATA.readlines()
                    TSTEPS = len(DATA) - 1
                    ## DETERMINE IF TRANSITION DENSITY FILES EXIST AND OPEN THEM ## 
                    if not os.path.exists('%s/%04d/transition-densities.out' % (NEXMD,DIR)):
                        print >> ERROR, '%s%04d/transition-densities.out' % (NEXMD,DIR)
                        ERRFLAG = 1
                        TTRAJ += 1
                        continue
                    TDS = open('%s/%04d/transition-densities.out' % (NEXMD,DIR),'r')
                    TDS = TDS.readlines()
                    ## COMPARE COMPLETED TIME-STEPS TO COLLECTION TIME-STEPS AND COLLECT DATA ##
                    if TSTEPS >= TSCOL:
                        SOCC = np.zeros((TSCOL,NATOMS))
                        TFLAG = 0
                        INDEX = 0
                        for LINE in LINENUMS:
                            VAL = np.float_(TDS[LINE].split())
                            TIME = np.around(VAL[0], decimals = 3)
                            if TIME != TIMES[INDEX]:
                                print >> ERROR, 'There is an inconsistency in time-step in %s%04d at %.3f fs' % (NEXMD,DIR,TIMES[INDEX])
                                TFLAG = 1
                                ERRFLAG = 1
                                break
                            SOCC[INDEX] = np.abs(VAL[1::])/np.sum(np.abs(VAL[1::]))
                            INDEX += 1
                        if TFLAG == 0:
                            FOCC += SOCC
                            CTRAJ += 1
                            if TSTEPS == TSMAX:
                                ETRAJ += 1
                    else:
                        print >> ERROR, '%s%04d' % (NEXMD,DIR), '%0*.2f' % (len(str((TSMAX))) + 2, (TSTEPS - 1)*DT)
                        ERRFLAG = 1
                    print '%s%04d' % (NEXMD,DIR), '%0*.2f' % (len(str((TSMAX))) + 2, (TSTEPS - 1)*DT)
                    TTRAJ += 1
            ## SUMMARY OF RESULTS ##
            if CTRAJ == 0:
                print 'No trajectories completed within %0*.2f fs.' % (len(str(TSMAX)), TCOLL)
                os.remove('%s/td_mean_ensemble.out' % (CWD))
            else:
                ## AVERAGE COEFFICIENTS ##
                FOCC = FOCC/CTRAJ
                ## GENERATE ARRAY FOR FRAGMENT OCCUPANCIES ##
                FRAGOCC = np.zeros((TSCOL, NFRAG))
                ## SPLIT DATA BY ATOMS ##
                INDEX = 0
                for LINE in FOCC:
                    DATA = np.split(LINE, ORBITALS)[0:NATOMS:1]
                    SOCC = np.zeros(NATOMS)
                    SINDEX = 0
                    for LINE in DATA:
                        SOCC[SINDEX] = np.sum(LINE)
                        SINDEX += 1
                    ## SPLIT DATA BY FRAGMENTS ##
                    FINDEX = 0
                    for FRAGMENT in FRAGMENTS:
                        FRAGOCC[INDEX, FINDEX] = np.sum(SOCC[np.int_(FRAGMENT)])
                        FINDEX += 1
                    INDEX += 1
                print 'Total Trajectories:', '%04d' % (TTRAJ)
                print 'Completed Trajectories:', '%04d' % (CTRAJ)
                print 'Excellent Trajectories:', '%04d' % (ETRAJ)
                print >> OUTPUT, 'Total Trajectories:', '%04d' % (TTRAJ)
                print >> OUTPUT, 'Completed Trajectories:', '%04d' % (CTRAJ)
                print >> OUTPUT, 'Excellent Trajectories:', '%04d' % (ETRAJ)
                for TSTEP in np.arange(TSCOL):
                    print >> OUTPUT, '%0*.2f' % (len(str((TSMAX))) + 2, TSTEP*DT), ' '.join(str('%.3f' % (x)) for x in FOCC[TSTEP]), '%.3f' % (np.sum(FOCC[TSTEP]))
            if ERRFLAG == 1:
                print 'One or more trajectories have experienced an error, check td_mean_ensemble.err' % (len(str(TSMAX)), TCOLL)
            else:
                os.remove('%s/td_mean_ensemble.err' % (CWD))
                
    ## NON-ADIABTIC ENSEMBLE ##
    if DYNQ == 0 and BOFLAG == 0:
        ## ALL TIME-STEPS - NON-ADIABATIC ENSEMBLE ##
        if TYPEQ == 1:
            ## GENERATE OUTPUT/ERROR FILES ##
            OUTPUT = open('%s/td_raw_ensemble.out' % (NEXMD))
            ERROR = open('%s/td_raw_ensemble.err' % (NEXMD))
            ## BEGIN LOOPING OVER TRAJECTORIES ##
            TTRAJ = 0
            CTRAJ = 0
            ETRAJ = 0
            ERRFLAG = 0
            for NEXMD in NEXMDS:
                if not os.path.exists('%s/dirlist1' % (NEXMD)):
                    print 'Path %sdirlist1 does not exist.' % (NEXMD)
                    sys.exit()
                DIRLIST1 = np.int_(np.genfromtxt('%s/dirlist1' % (NEXMD)))
                if isinstance(DIRLIST1,int) == True:
                    DIRLIST1 = np.array([DIRLIST1])
                for DIR in DIRLIST1:
                    ## DETERMINE COMPLETED NUMBER OF TIME-STEPS ##
                    if not os.path.exists('%s/%04d/energy-ev.out' % (NEXMD,DIR)):
                        print >> ERROR, '%s%04d/energy-ev.out' % (NEXMD,DIR), 'does not exist'
                        ERRFLAG = 1
                        TTRAJ += 1
                        continue
                    DATA = open('%s/%04d/energy-ev.out' % (NEXMD,DIR),'r')
                    DATA = DATA.readlines()
                    TSTEPS = len(DATA) - 1
                    ## DETERMINE IF COEFFICIENT FILES EXIST AND OPEN THEM ##
                    if not os.path.exists('%s/%04d/coeff-n.out' % (NEXMD,DIR)):
                        print >> ERROR, '%s%04d/coeff-n.out' % (NEXMD,DIR)
                        ERRFLAG = 1
                        TTRAJ += 1
                        continue
                    HOPS = open('%s/%04d/coeff-n.out' % (NEXMD,DIR),'r')
                    HOPS = HOPS.readlines()
                    HSTEPS = len(HOPS)
                    ## DETERMINE IF TRANSITION DENSITY FILES EXIST AND OPEN THEM ##
                    if not os.path.exists('%s/%04d/transition-densities.out' % (NEXMD,DIR)):
                        print >> ERROR, '%s%04d/transition-densities.out' % (NEXMD,DIR)
                        ERRFLAG = 1
                        TTRAJ += 1
                        continue
                    TDS = open('%s/%04d/transition-densities.out' % (NEXMD,DIR),'r')
                    TDS = TDS.readlines()
                    ## COLLECT DATA ##
                    TFLAG = 0
                    INDEX = 0
                    CSTATE = np.int(HOPS[0].split()[0])
                    for LINE in LINENUMS:
                        if LINE <= HSTEPS:
                            NSTATE = np.int(HOPS[LINE].split()[0])
                        VAL = np.float_(TDS[LINE].split())
                        TIME = np.around(VAL[0], decimals = 3)
                        if TIME != TIMES[INDEX]:
                            print >> ERROR, 'There is an inconsistency in time-step in %s%04d at %.3f fs' % (NEXMD,DIR,TIMES[INDEX])
                            TFLAG = 1
                            ERRFLAG = 1
                            break
                        print >> OUTPUT, '%s%04d' % (NEXMD,DIR), '%d' % (CSTATE), '%d' % (NSTATE), ' '.join(str('%.10f') % (x) for x in np.abs(VAL[1::])/np.sum(np.abs(VAL[1::])))
                        CSTATE = NSTATE
                        INDEX += 1
                    if TFLAG == 0:
                        CTRAJ += 1
                        if TSTEPS == TSMAX:
                            ETRAJ += 1
                    print '%s%04d' % (NEXMD,DIR), '%0*.2f' % (len(str((TSMAX))) + 2, (TSTEPS - 1)*DT)
                    TTRAJ += 1
            ## SUMMARY OF RESULTS ##
            if CTRAJ == 0:
                print 'No trajectories completed within %0*.2f fs.' % (len(str(TSMAX)), TCOLL)
                os.remove('%s/td_raw_ensemble.out' % (CWD))
            else:
                print 'Total Trajectories:', '%04d' % (TTRAJ)
                print 'Completed Trajectories:', '%04d' % (CTRAJ)
                print 'Excellent Trajectories:', '%04d' % (ETRAJ)
            if ERRFLAG == 1:
                print 'One or more trajectories have experienced an error, check td_raw_ensemble.err.' % (len(str(TSMAX)), TCOLL)
            else:
                os.remove('%s/td_raw_ensemble.err' % (CWD))

        ## USER-DEFINED TIME-STEPS - NON-ADIABATIC ENSEMBLE ##
        if TYPEQ == 2:
            ## GENERATE OUTPUT/ERROR FILES ##
            OUTPUT = open('%s/td_raw_ensemble.out' % (CWD),'w')
            ERROR = open('%s/td_raw_ensemble.err' % (CWD),'w')
            ## BEGIN LOOPING OVER TRAJECTORIES ##
            TTRAJ = 0
            CTRAJ = 0
            ETRAJ = 0
            ERRFLAG = 0
            for NEXMD in NEXMDS:
                if not os.path.exists('%s/dirlist1' % (NEXMD)):
                    print 'Path %sdirlist1 does not exist.' % (NEXMD)
                    sys.exit()
                DIRLIST1 = np.int_(np.genfromtxt('%s/dirlist1' % (NEXMD)))
                if isinstance(DIRLIST1,int) == True:
                    DIRLIST1 = np.array([DIRLIST1])
                for DIR in DIRLIST1:
                    ## DETERMINE COMPLETED NUMBER OF TIME-STEPS ##
                    if not os.path.exists('%s/%04d/energy-ev.out' % (NEXMD,DIR)):
                        print >> ERROR, '%s%04d/energy-ev.out' % (NEXMD,DIR), 'does not exist'
                        ERRFLAG = 1
                        TTRAJ += 1
                        continue
                    DATA = open('%s/%04d/energy-ev.out' % (NEXMD,DIR),'r')
                    DATA = DATA.readlines()
                    TSTEPS = len(DATA) - 1
                    ## DETERMINE IF COEFFICIENT FILES EXIST AND OPEN THEM ##
                    if not os.path.exists('%s/%04d/coeff-n.out' % (NEXMD,DIR)):
                        print >> ERROR, '%s%04d/coeff-n.out' % (NEXMD,DIR)
                        ERRFLAG = 1
                        TTRAJ += 1
                        continue
                    HOPS = open('%s/%04d/coeff-n.out' % (NEXMD,DIR),'r')
                    HOPS = HOPS.readlines()
                    HSTEPS = len(HOPS)
                    ## DETERMINE IF TRANSITION DENSITY FILES EXIST AND OPEN THEM ##
                    if not os.path.exists('%s/%04d/transition-densities.out' % (NEXMD,DIR)):
                        print >> ERROR, '%s%04d/transition-densities.out' % (NEXMD,DIR)
                        ERRFLAG = 1
                        TTRAJ += 1
                        continue
                    TDS = open('%s/%04d/transition-densities.out' % (NEXMD,DIR),'r')
                    TDS = TDS.readlines()
                    ## COMPARE COMPLETED TIME-STEPS TO COLLECTION TIME-STEPS AND COLLECT DATA ##
                    if TSTEPS >= TSCOL:
                        TFLAG = 0
                        INDEX = 0
                        CSTATE = np.int(HOPS[0].split()[0])
                        for LINE in LINENUMS:
                            if LINE <= HSTEPS:
                                NSTATE = np.int(HOPS[LINE].split()[0])
                            VAL = np.float_(TDS[LINE].split())
                            TIME = np.around(VAL[0], decimals = 3)
                            if TIME != TIMES[INDEX]:
                                print >> ERROR, 'There is an inconsistency in time-step in %s%04d at %.3f fs' % (NEXMD,DIR,TIMES[INDEX])
                                TFLAG = 1
                                ERRFLAG = 1
                                break
                            print >> OUTPUT, '%s%04d' % (NEXMD,DIR), '%d' % (CSTATE), '%d' % (NSTATE), ' '.join(str('%.10f') % (x) for x in np.abs(VAL[1::])/np.sum(np.abs(VAL[1::])))
                            CSTATE = NSTATE
                            INDEX += 1
                        if TFLAG == 0:
                            CTRAJ += 1
                            if TSTEPS == TSMAX:
                                ETRAJ += 1
                        print '%s%04d' % (NEXMD,DIR), '%0*.2f' % (len(str((TSMAX))) + 2, (TSTEPS - 1)*DT)
                        TTRAJ += 1
                ## SUMMARY OF RESULTS ##
                if CTRAJ == 0:
                    print 'No trajectories completed within %0*.2f fs.' % (len(str(TSMAX)), TCOLL)
                    os.remove('%s/td_raw_ensemble.out' % (CWD))
                else:
                    print 'Total Trajectories:', '%04d' % (TTRAJ)
                    print 'Completed Trajectories:', '%04d' % (CTRAJ)
                    print 'Excellent Trajectories:', '%04d' % (ETRAJ)
                if ERRFLAG == 1:
                    print 'One of more trajectories have experienced an error, check td_raw_ensemble.err.' % (len(str(TSMAX)), TCOLL)
                else:
                    os.remove('%s/td_raw_ensemble.err' % (CWD))
                    
        ## CALCULATE MEAN - NON-ADIABATC ENSEMBLE ##
        if TYPEQ == 0:
            ## GENERATE OCCUPANCY ARRAY FOR FINAL RESULTS ##
            FOCC = np.zeros((TSCOL,NORBITS))
            ## GENERATE OUTPUT/ERROR FILES ##
            OUTPUT = open('%s/td_mean_ensemble.out' % (CWD),'w')
            ERROR = open('%s/td_mean_ensemble.err' % (CWD),'w')
            ## BEGIN LOOPING OVER TRAJECTORIES ##
            TTRAJ = 0
            CTRAJ = 0
            ETRAJ = 0
            ERRFLAG = 0
            for NEXMD in NEXMDS:
                if not os.path.exists('%s/dirlist1' % (NEXMD)):
                    print 'Path %sdirlist1 does not exist.' % (NEXMD)
                    sys.exit()
                DIRLIST1 = np.int_(np.genfromtxt('%s/dirlist1' % (NEXMD)))
                if isinstance(DIRLIST1, int) == True:
                    DIRLIST1 = np.array([DIRLIST1])
                for DIR in DIRLIST1:
                    ## DETERMINE COMPLETED NUMBER OF TIME-STEPS ##
                    if not os.path.exists('%s/%04d/energy-ev.out' % (NEXMD,DIR)):
                        print >> ERROR, '%s%04d/energy-ev.out' % (NEXMD,DIR), 'does not exist'
                        ERRFLAG = 1
                        TTRAJ += 1
                        continue
                    DATA = open('%s/%04d/energy-ev.out' % (NEXMD,DIR),'r')
                    DATA = DATA.readlines()
                    TSTEPS = len(DATA) - 1
                    ## DETERMINE IF TRANSITION DENSITY FILES EXIST AND OPEN THEM ## 
                    if not os.path.exists('%s/%04d/transition-densities.out' % (NEXMD,DIR)):
                        print >> ERROR, '%s%04d/transition-densities.out' % (NEXMD,DIR)
                        ERRFLAG = 1
                        TTRAJ += 1
                        continue
                    TDS = open('%s/%04d/transition-densities.out' % (NEXMD,DIR),'r')
                    TDS = TDS.readlines()
                    ## COMPARE COMPLETED TIME-STEPS TO COLLECTION TIME-STEPS AND COLLECT DATA ##
                    if TSTEPS >= TSCOL:
                        SOCC = np.zeros((TSCOL,NORBITS))
                        TFLAG = 0
                        INDEX = 0
                        for LINE in LINENUMS:
                            VAL = np.float_(TDS[LINE].split())
                            TIME = np.around(VAL[0], decimals = 3)
                            if TIME != TIMES[INDEX]:
                                print >> ERROR, 'There is inconsistency in time-step in %s%04d at %.3f fs' % (NEXMD,DIR,TIMES[INDEX])
                                TFLAG = 1
                                ERRFLAG = 1
                                break
                            #SOCC[INDEX] = np.abs(VAL[1::])/np.sum(np.abs(VAL[1::]))
                            #SOCC[INDEX] = np.abs(np.sum(np.split(VAL[1::],ORBITALS)[0:NATOMS:1],axis=1))
                            SOCC[INDEX] = VAL[1::]
                            INDEX += 1
                        if TFLAG == 0:
                            FOCC += SOCC
                            CTRAJ += 1
                            if TSTEPS == TSMAX:
                                ETRAJ += 1
                    else:
                        print >> ERROR, '%s%04d' % (NEXMD,DIR), '%0*.2f' % (len(str(TSMAX)) + 2, (TSTEPS - 1)*DT)
                        ERRFLAG = 1
                    print '%s%04d' % (NEXMD,DIR), '%0*.2f' % (len(str(TSMAX)) + 2, (TSTEPS - 1)*DT)
                    TTRAJ += 1
            ## SUMMARY OF RESULTS ##
            if CTRAJ == 0:
                print 'No trajectories completed within %0*.2f fs.' % (len(str(TSMAX)), TCOLL)
                os.remove('%s/td_mean_ensemble.out' % (CWD))
            else:
                ## AVERAGE COEFFICIENTS ##
                FOCC = FOCC/CTRAJ
                ## GENERATE ARRAY FOR FRAGMENT OCCUPANCIES ##
                FRAGOCC = np.zeros((TSCOL, NFRAG))
                ## SPLIT DATA BY ATOMS ##
                INDEX = 0
                for LINE in FOCC:
                    DATA = np.split(LINE, ORBITALS)[0:NATOMS:1]
                    SOCC = np.zeros(NATOMS)
                    #EXCITONLOC=np.zeros(NATOMS) ok, we are working from here
                    SINDEX = 0
                    for LINE in DATA:
                        #SOCC[SINDEX] = np.sum(LINE)
                        SOCC[SINDEX] = np.abs(np.sum(LINE))
                        SINDEX += 1
                    ## SPLIT DATA BY FRAGMENTS ##
                    FINDEX = 0
                    for FRAGMENT in FRAGMENTS:
                        FRAGOCC[INDEX, FINDEX] = np.sum(SOCC[np.int_(FRAGMENT)])/np.sum(SOCC)
                        FINDEX += 1
                    INDEX += 1
                print 'Total Trajectories:', '%04d' % (TTRAJ)
                print 'Completed Trajectories:', '%04d' % (CTRAJ)
                print 'Excellent Trajectories:', '%04d' % (ETRAJ)
                print >> OUTPUT, 'Total Trajectories:', '%04d' % (TTRAJ)
                print >> OUTPUT, 'Completed Trajectories:', '%04d' % (CTRAJ)
                print >> OUTPUT, 'Excellent Trajectories:', '%04d' % (ETRAJ)
                for TSTEP in np.arange(TSCOL):
                    print >> OUTPUT, '%0*.2f' % (len(str((TSMAX))) + 2, TSTEP*DT), ' '.join(str('%.3f' % (x)) for x in FRAGOCC[TSTEP]), '%.3f' % (np.sum(FRAGOCC[TSTEP]))
            if ERRFLAG == 1:
                print 'One or more trajectories have experienced an error, check td_mean_ensemble.err' % (len(str(TSMAX)), TCOLL)
            else:
                os.remove('%s/td_mean_ensemble.err' % (CWD))
                
